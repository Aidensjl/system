**数据结构**
数组，链表，栈，队列，散列表，二叉树，堆，跳表，图，Trie树


**算法**
递归，排序，二分查找，搜索，哈希算法，贪心算法，分治算法，回溯算法，动态规划，字符串匹配算法
（B树，B+树，Bm算法了解原理即可） 

**刷题**
第一遍：5-10分钟读题和思考，背诵默写
第二遍：立刻写
第三遍：过一天重复写
第四遍：过一周继续练习
第五遍：面试前一周恢复性训练


**时间和空间复杂度（大O表示法）** 
O（1）<O（logn）<O（n）<O（nlogn）<O（n^2）<O（n^3）<O（2^n）<O(n!)<O(n^n)  






实习：
熟悉常用的激光、视觉SLAM算法、路径规划算法、避障算法、以及运动控制算法；
精通Cartographer、Gmapping等主流的SLAM开源系统，对至少其中一个框架有过源码阅读经验；
熟悉OpenCV等常用计算机视觉和图像处理算法，有SFM、SLAM、BA理论基础；
掌握常见的非线性优化算法；
熟悉OpenCV、g2o、Ceres等SLAM相关的库以及VINS、CartographerKarto等一种或多种SLAM开源框架。
负责多个传感器之间的标定
cmake -DCMAKE_INSTALL_PREFIX=/usr/local/sophus ..




cmakel例子
https://www.cnblogs.com/newneul/p/8367421.html

在面试中，以下是一些与算法相关的高频提问，你可能会遇到其中一些问题：

1. 时间复杂度和空间复杂度是什么？如何计算一个算法的时间复杂度和空间复杂度？
2. 什么是数组和链表？它们的优缺点是什么？在何种情况下使用哪种数据结构更合适？
3. 什么是栈和队列？它们的应用场景是什么？
4. 什么是递归？如何使用递归解决问题？递归有什么优缺点？
5. 什么是排序算法？请解释并分析几种常见的排序算法（如冒泡排序、插入排序、快速排序等）的原理、时间复杂度和空间复杂度。
6. 什么是二分查找？如何在有序数组中使用二分查找算法？它的时间复杂度是多少？
7. 什么是哈希表？它的原理是什么？如何处理哈希冲突？哈希表的时间复杂度是多少？
8. 什么是图？请解释图的表示方法和常见的图遍历算法（如深度优先搜索和广度优先搜索）。
9. 什么是动态规划？如何使用动态规划解决问题？请提供一个动态规划的实例。
10. 什么是贪心算法？如何使用贪心算法解决问题？请提供一个贪心算法的实例。



1. 时间复杂度（Time Complexity）是衡量算法运行时间随输入规模增长而增长的速度。通常用大O表示法表示。空间复杂度（Space Complexity）是衡量算法在执行过程中所需的额外空间量。时间复杂度和空间复杂度可以通过分析算法中的循环、递归和数据结构等来计算。

2. 数组（Array）是一种线性数据结构，用于存储固定大小的相同类型元素。它具有随机访问和连续存储的特点，但插入和删除元素的操作效率较低。链表（Linked List）是一种通过指针连接节点的数据结构，它允许高效的插入和删除操作，但访问元素需要遍历。在选择数据结构时，应根据实际需求考虑其读取和修改的操作频率、内存占用和数据的稳定性等因素。

3. 栈（Stack）是一种后进先出（LIFO）的数据结构，用于实现函数调用、表达式求值等。队列（Queue）是一种先进先出（FIFO）的数据结构，常用于任务调度、缓存等场景。

4. 递归是一种通过在函数内部调用自身来解决问题的方法。递归函数通常包括一个基本情况（递归终止条件）和一个递归调用。递归的优点是能简化问题的表达和实现，但过度使用递归可能导致栈溢出和性能问题。

5. 排序算法是将一组元素按照特定顺序进行排列的算法。常见的排序算法有冒泡排序、插入排序、选择排序、快速排序、归并排序等。每个排序算法的原理和性能特点不同，可以根据数据规模、稳定性要求和时间复杂度等因素选择适当的排序算法。

6. 二分查找是一种在有序数组中查找特定元素的算法。它通过将目标值与数组中间元素进行比较，从而缩小搜索范围。二分查找的时间复杂度是O(log n)。

7. 哈希表（Hash Table）是一种基于哈希函数实现的数据结构，用于存储键值对。它通过将键映射到存储位置来实现高效的插入、删除和查找操作。处理哈希冲突的方法包括开放地址法和链地址法。哈希表的平均时间复杂度是O(1)，但最坏情况下可能是O(n)。

8. 图（Graph）是由节点（顶点）和边组成的一种非线性数据结构。图可以用邻接矩阵或邻接表表示。深度优先搜索（DFS）和广度优先搜索（BFS）是常用的图遍历算法，用于查找图中的节点或解决连通性问题。

9. 动态规划（Dynamic Programming）是一种通过将问题分解为重叠子问题并存储子问题的解来解决复杂问题的方法。动态规划通常涉及状态定义、状态转移方程和初始条件的确定。它用于解决具有重叠子问题和最优子结构性质的问题，如最长递增子序列、背包问题等。

10. 贪心算法（Greedy Algorithm）是一种在每个步骤选择局部最优解以期望获得全局最优解的方法。贪心算法通常不进行回溯，而是根据当前情况做出决策。它用于解决一些最优化问题，如最小生成树、最短路径等。

